<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <title>Kanagawa</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Honk&family=Ubuntu+Mono:wght@700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        min-width: 0;
        box-sizing: border-box;
        line-height: 1;
      }

      html,
      body {
        height: 100vh;
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 4vmin;
        text-align: center;
        color: #1e4769;
        background-color: #f9c098;
        padding: 0 5vw;
      }

      h1 {
        font-family: "Honk", serif, sans-serif, monospace;
        font-size: 12vmin;
      }

      canvas {
        width: min(800px, 90vw);
        aspect-ratio: 4/3;
        border-radius: 8px;
        box-shadow: 0 0 16px rgba(222, 121, 5, 0.4);
      }

      footer {
        font-family: "Ubuntu Mono", monospace;
        font-size: 2vmin;
        font-weight: 700;
      }

      a {
        color: inherit;
      }
    </style>
  </head>

  <body>
    <h1>Kanagawa</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <footer>
      <div>Made by Tsopeh â€” GitHub | Twitter</div>
      <br />
      <div>
        <a href="https://twitter.com/vnglst/status/1751278052154179770"
          >Inspiration</a
        >
        |
        <a href="https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa"
          >Theme</a
        >
        | <a href="https://www.color-hex.com/color-palette/39047">Palette</a>
      </div>
    </footer>
    <script>
      // @ts-check

      /**
       * @typedef {{
       *  x: number
       *  y: number
       *  dx: number
       *  dy: number
       *  color: string
       *  tileColors: Array<string>
       * }} Player
       *
       * @typedef {Array<Array<string>>} Board
       *
       * @typedef {{
       *  player1: Player
       *  player2: Player
       *  board: Board
       * }} State
       */

      const canvas = /** @type {HTMLCanvasElement} */ (
        document.getElementById("canvas")
      );
      if (!canvas) throw new Error("Missing canvas element");
      const ctx = /** @type {CanvasRenderingContext2D} */ (
        canvas.getContext("2d")
      );
      if (!ctx) throw new Error("Failed to create the 2D context");

      const squareSize = 25;
      const squareXCount = canvas.width / squareSize;
      const squareYCount = canvas.height / squareSize;
      const initialPlayerSpeed = 8;

      const state = getInitialState();

      /** @type {FrameRequestCallback} */
      function draw(t) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard(state.board);
        drawPlayer(state.player1);
        drawPlayer(state.player2);
        const delayBeforeStartMs = 1000;
        if (t > delayBeforeStartMs) {
          recalculateState(state);
        }
        requestAnimationFrame(draw);
      }

      requestAnimationFrame(draw);

      /** @param min {number} @param max {number} @returns {number} */
      function random(min, max) {
        return Math.random() * (max - min) + min;
      }

      /** @template T @param arr {Array<T>}, @returns {T} */
      function randomArrayItem(arr) {
        const randomIndex = Math.round(random(0, arr.length - 1));
        return arr[randomIndex];
      }

      /** @param board {Board} */
      function drawBoard(board) {
        for (let i = 0; i < squareXCount; i++) {
          for (let j = 0; j < squareYCount; j++) {
            ctx.fillStyle = board[i][j];
            ctx.fillRect(
              i * squareSize,
              j * squareSize,
              squareSize,
              squareSize
            );
          }
        }
      }

      /** @param player {Player} */
      function drawPlayer(player) {
        ctx.beginPath();
        ctx.arc(player.x, player.y, squareSize, 0, 2 * Math.PI, false);
        ctx.fillStyle = player.color;
        ctx.fill();
        ctx.closePath();
      }

      /** @param state {State} */
      function recalculateState(state) {
        const { player1, player2, board } = state;

        player1.x += player1.dx;
        player1.y += player1.dy;

        player2.x += player2.dx;
        player2.y += player2.dy;

        // TODO: Implement collision detection
      }

      /** @returns {State} */
      function getInitialState() {
        const player1Colors = ["#edd5ad", "#f0e0bb", "#f2e8d0"];
        const player2Colors = ["#19869c", "#3d5066"];

        /** @type {Player} */
        const player1 = {
          x: canvas.width * (1 / 4),
          y: canvas.height / 2,
          dx: initialPlayerSpeed,
          dy: -1 * initialPlayerSpeed,
          color: randomArrayItem(player1Colors),
          tileColors: player2Colors,
        };

        /** @type {Player} */
        const player2 = {
          x: canvas.width * (3 / 4),
          y: canvas.height / 2,
          dx: -1 * initialPlayerSpeed,
          dy: initialPlayerSpeed,
          color: randomArrayItem(player2Colors),
          tileColors: player1Colors,
        };

        /** @type {Board} */
        let board = [];
        for (let i = 0; i < squareXCount; i++) {
          board[i] = [];
          for (let j = 0; j < squareYCount; j++) {
            const colors =
              i < squareXCount / 2 ? player1.tileColors : player2.tileColors;
            board[i][j] = randomArrayItem(colors);
          }
        }

        return { player1, player2, board };
      }

      // TODO: Finish the game and after that implement color changing.
      // Maybe different strategy for wave and the land;
      // Use different starting angle, to resemble the original piece.
    </script>
  </body>
</html>
