<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <title>Kanagawa</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Honk&family=Ubuntu+Mono:wght@700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        min-width: 0;
        box-sizing: border-box;
        line-height: 1;
      }

      html,
      body {
        height: 100vh;
      }

      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 4vmin;
        text-align: center;
        color: #1e4769;
        background-color: #f9c098;
        padding: 0 5vw;
      }

      h1 {
        font-family: "Honk", serif, sans-serif, monospace;
        font-size: 12vmin;
      }

      canvas {
        width: min(800px, 90vw);
        aspect-ratio: 4/3;
        border-radius: 8px;
        box-shadow: 0 0 16px rgba(222, 121, 5, 0.4);
      }

      footer {
        font-family: "Ubuntu Mono", monospace;
        font-size: 2vmin;
        font-weight: 700;
      }

      a {
        color: inherit;
      }
    </style>
  </head>

  <body>
    <h1>Kanagawa</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    <footer>
      <div>Made by Tsopeh â€” GitHub | Twitter</div>
      <br />
      <div>
        <a href="https://twitter.com/vnglst/status/1751278052154179770"
          >Inspiration</a
        >
        |
        <a href="https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa"
          >Theme</a
        >
        | <a href="https://www.color-hex.com/color-palette/39047">Palette</a>
      </div>
    </footer>
    <script>
      // @ts-check

      // TODO: Finish the game and after that implement color changing.
      // Maybe different strategy for wave and the land;
      // Use different starting angle, to resemble the original piece.

      /**
       * @typedef {{
       *  x: number
       *  y: number
       *  dx: number
       *  dy: number
       *  color: string
       *  tileColors: Array<string>
       * }} Player
       *
       * @typedef {Array<Array<string>>} Board
       *
       * @typedef {{
       *  player1: Player
       *  player2: Player
       *  board: Board
       * }} State
       */

      const canvas = /** @type {HTMLCanvasElement} */ (
        document.getElementById("canvas")
      );
      if (!canvas) throw new Error("Missing canvas element");
      const ctx = /** @type {CanvasRenderingContext2D} */ (
        canvas.getContext("2d")
      );
      if (!ctx) throw new Error("Failed to create the 2D context");

      const squareSize = 40;
      const squareXCount = canvas.width / squareSize;
      const squareYCount = canvas.height / squareSize;
      const initialPlayerSpeed = 8;

      const state = getInitialState();

      /** @type {FrameRequestCallback} */
      function draw(t) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBoard(state.board);
        drawPlayer(state.player1);
        drawPlayer(state.player2);

        const delayBeforeStartMs = 200;
        if (t > delayBeforeStartMs) {
          recalculateState(state);
        }

        requestAnimationFrame(draw);
      }

      requestAnimationFrame(draw);

      /** @param min {number}
       *  @param max {number}
       *  @returns {number}
       */
      function random(min, max) {
        return Math.random() * (max - min) + min;
      }

      /** @template T @param arr {Array<T>}, @returns {T} */
      function randomArrayItem(arr) {
        const randomIndex = Math.round(random(0, arr.length - 1));
        return arr[randomIndex];
      }

      /** @param board {Board} */
      function drawBoard(board) {
        for (let i = 0; i < squareXCount; i++) {
          for (let j = 0; j < squareYCount; j++) {
            ctx.fillStyle = board[i][j];
            ctx.fillRect(
              i * squareSize,
              j * squareSize,
              squareSize,
              squareSize
            );
          }
        }
      }

      /** @param player {Player} */
      function drawPlayer(player) {
        ctx.beginPath();
        ctx.arc(player.x, player.y, squareSize, 0, 2 * Math.PI, false);
        ctx.fillStyle = player.color;
        ctx.fill();
        ctx.closePath();
      }

      /**
       * @param state {State}
       */
      function recalculateState(state) {
        const { player1, player2, board } = state;

        const p1HitAngles = updateBoardForPlayer(board, player1);
        const p2HitAngles = updateBoardForPlayer(board, player2);

        updatePlayerDirectionAndVelocity(player1, p1HitAngles);
        updatePlayerDirectionAndVelocity(player2, p2HitAngles);

        updatePlayerPosition(player1);
        updatePlayerPosition(player2);
      }

      /** @param player {Player} */
      function updatePlayerPosition(player) {
        player.x += player.dx;
        player.y += player.dy;
      }

      /**
       * @param board {Board}
       * @param player {Player}
       * @returns {Array<number>}
       */
      function updateBoardForPlayer(board, player) {
        /** @type {Array<number>} */
        const hitAngles = [];
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
          const checkX = player.x + Math.cos(angle) * squareSize / 2;
          const checkY = player.y + Math.sin(angle) * squareSize / 2;

          const i = Math.floor(checkX / squareSize);
          const j = Math.floor(checkY / squareSize);

          const isInBounds =
            i >= 0 && i < squareXCount && j >= 0 && j < squareYCount;
          if (isInBounds) {
            const isHit = !player.tileColors.includes(board[i][j]);
            if (isHit) {
              board[i][j] = randomArrayItem(player.tileColors);
              hitAngles.push(angle);
            } else {
              // noop
            }
          } else {
            hitAngles.push(angle);
          }
        }
        return hitAngles;
      }

      /**
       * @param player {Player}
       * @param hitAngles {Array<number>}
       */
      function updatePlayerDirectionAndVelocity(player, hitAngles) {
        if (hitAngles.length === 0) {
          return;
        }
        const { xDir, yDir } = hitAngles.reduce(
          (acc, hitAngle) => {
            const shouldConsiderX =
              Math.abs(Math.cos(hitAngle)) >= Math.abs(Math.sin(hitAngle));
            if (shouldConsiderX) {
              const hitDirX = Math.sign(Math.cos(hitAngle));
              const travelDirX = Math.sign(player.dx);
              if (hitDirX === travelDirX) {
                acc.xDir = -1;
              }
            } else {
              const hitDirY = Math.sign(Math.sin(hitAngle));
              const travelDirY = Math.sign(player.dy);
              if (hitDirY === travelDirY) {
                acc.yDir = -1;
              }
            }
            return acc;
          },
          { xDir: 1, yDir: 1 }
        );
        const newVelocityX = Math.floor(random(8, 10));
        const newVelocityY = Math.floor(random(8, 10));
        player.dx = xDir * Math.sign(player.dx) * newVelocityX;
        player.dy = yDir * Math.sign(player.dy) * newVelocityY;
      }

      /** @returns {State} */
      function getInitialState() {
        const player1Colors = ["#edd5ad", "#f0e0bb", "#f2e8d0"];
        const player2Colors = ["#19869c", "#3d5066"];

        /** @type {Player} */
        const player1 = {
          x: canvas.width * (1 / 4),
          y: canvas.height / 2,
          dx: initialPlayerSpeed,
          dy: -1 * initialPlayerSpeed,
          color: randomArrayItem(player1Colors),
          tileColors: player2Colors,
        };

        /** @type {Player} */
        const player2 = {
          x: canvas.width * (3 / 4),
          y: canvas.height / 2,
          dx: -1 * initialPlayerSpeed,
          dy: initialPlayerSpeed,
          color: randomArrayItem(player2Colors),
          tileColors: player1Colors,
        };

        /** @type {Board} */
        let board = [];
        for (let i = 0; i < squareXCount; i++) {
          board[i] = [];
          for (let j = 0; j < squareYCount; j++) {
            const colors =
              i < squareXCount / 2 ? player1.tileColors : player2.tileColors;
            board[i][j] = randomArrayItem(colors);
          }
        }

        return { player1, player2, board };
      }
    </script>
  </body>
</html>
